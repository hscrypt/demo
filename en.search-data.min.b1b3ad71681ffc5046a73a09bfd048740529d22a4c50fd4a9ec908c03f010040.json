[{"id":0,"href":"/","title":"Index","section":"hscrypt demos","content":"hscrypt demos #  Examples using hscrypt and hscrypt-webpack-plugin to encrypt and deploy static sites.\nhscrypt simulates \u0026ldquo;anyone with the link can view\u0026rdquo; permissioning for publicly-hosted static web apps (e.g. on GitHub Pages). Please read the Disclaimer section before using.\nHello World #  Here\u0026rsquo;s a simple example (taken from 00-simple:\n\u0026lt;!-- index.html --\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; This page is encrypted! Please provide password as URL hash. \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; // secret.js document.body.innerHTML = \u0026#39;secret message üêø\u0026#39; // inject secret message (or an entire application!) somewhere on page // webpack.config.js const path = require(\u0026#34;path\u0026#34;) const HTMLWebpackPlugin = require(\u0026#34;html-webpack-plugin\u0026#34;); const HscryptPlugin = require(\u0026#34;hscrypt-webpack-plugin\u0026#34;).default; module.exports = { entry: \u0026#34;./src/secret.js\u0026#34;, output: { path: path.resolve(__dirname, \u0026#39;dist\u0026#39;), filename: \u0026#34;bundle.js\u0026#34; }, plugins: [ new HTMLWebpackPlugin({ inject: true, template: \u0026#39;index.html\u0026#39; }), new HscryptPlugin({ path: \u0026#34;dist\u0026#34;, filename: \u0026#34;bundle.js\u0026#34;, pswd: \u0026#34;my-password\u0026#34; }) ] } # bash npm install webpack node_modules/.bin/webpack # build encrypted bundle http-server dist # serve dist/ folder Encrypted landing page #  Then open 127.0.0.1:8080 (or whichever port http-server prints):\nThis is index.html from above.\nDecrypting via URL-hash password #  If you know the password (set at build time in webpack.config.js above), you can decrypt the page by adding the password as a URL \u0026ldquo;hash\u0026rdquo;: http://127.0.0.1:8080#my-password:\nDecryption failure #  Incorrect password fails to decrypt, triggers an alert:\nDisclaimer #   There is cryptography here and I am not a cryptographer! Passwords should have ‚â•60 bits of entropy; see \u0026ldquo;Key Derivation\u0026rdquo;. I tried to use various crypto primitives correctly, but you should audit before trusting. I am not aware of any bugs, but to my knowledge no one else has looked at it. I make no representations that it is secure or does what it\u0026rsquo;s supposed to. My intention is to use hscrypt to host private data on GitHub Pages \u0026ldquo;soon\u0026rdquo;, and I will update this note when I do, but I am not currently relying on it \u0026ldquo;in production.\u0026rdquo;  I also intend to publish a honeypot encrypted site and offer a bounty ($20) to anyone that can break it (and explain it to me so that I can fix it üòÑ). I will also update this when that\u0026rsquo;s live.    Crypto(graphy) #  Here\u0026rsquo;s an overview of the cryptographic operations performed by hscrypt; please tell me if you spot any errors or think I\u0026rsquo;m thinking about something incorrectly.\nChaCha20 #  I found and used ChaChas20 after earlier experiments with PGP-encrypted pages (around gitlab.com/smondet/hscrypt), where my impression was that PGP-decryption at page load time was painfully slow. I searched for a faster symmetric cipher, and ChaCha20 seemed to be the best choice.\nI ported thesimj/js-chacha20 to typescript: hscrypt/ts-chacha20. I am trusting js-chacha20, and have not audited it.\nEncryption #  The encryption path is at hscrypt/js/src/encrypt.ts. Given:\n some Javascript source (e.g. the contents of a Webpack-compiled bundle.js; see hscrypt/webpack-plugin), a password a number of iterations for PBKDF2  optional, defaults to 20k, but requires very strong passwords! see ‚ö†Ô∏è PBKDF2 iterations ‚ö†Ô∏è below for caveats/discussion)    hscrypt.encrypt will:\n generate a 32-byte salt and 12-byte nonce pass salt, iterations, and password to PBKDF2 to obtain the \u0026ldquo;encryption key\u0026rdquo; initialize a ChaCha20 encoder with nonce and encryption key prepend a \u0026ldquo;magic string\u0026rdquo; (/* hscrypt */ ) to the JS source, encrypt it with ChaCha20 to obtain \u0026ldquo;ciphertext\u0026rdquo; concatenate salt, nonce, and ciphertext, return this buffer  Decryption #  Decryption of an encrypted script bundle happens in hscrypt._decrypt, and basically just inverts the encryption path.\nGiven inputs:\n encrypted buffer returned by hscrypt.encrypt password iterations (for PBKDF2) optional decryptionKeyHex: when cacheDecryptionKey is enabled, the decryption path can receive this value and skip an expensive key-derivation computation  hscrypt._decrypt will:\n slice nonce and ciphertext from encrypted buffer if decryptionKeyHex was not provided:  slice salt from encrypted buffer pass salt, iterations, and password to PBKDF2 to obtain the \u0026ldquo;decryption key\u0026rdquo;   initialize a ChaCha20 decoder with nonce and decryption key decrypt ciphertext using the ChaCha20 decoder to obtain \u0026ldquo;plaintext\u0026rdquo; verify that plaintext begins with the \u0026ldquo;magic string\u0026rdquo; /* hscrypt */ , remove it to obtain original Javascript source return source as well as decryption key (the latter allowing for callers to cache it, to implement cacheDecryptionKey)  Injection #  \u0026ldquo;Injection\u0026rdquo; of an encrypted script bundle into the page happens in hscrypt.inject which wraps the decryption path flow:\n check for password or decryption key in 3 places (short-circuiting on first find):  pswd argument to hscrypt.inject URL hash (e.g. http://127.0.0.1:8080#my-password above; if a hash is found, it\u0026rsquo;s immediately removed from the URL bar (‚ö†Ô∏è Ô∏èÔ∏èbut likely exists in your browser\u0026rsquo;s history, as plaintext ‚ö†Ô∏è) localStorage cache of decryption key (post-PBDKF2, not password; saves time on reload, when cacheDecryptionKey is enabled)   if no password or decryption key is found:  optionally register a \u0026quot;hashchange\u0026quot; listener  if the user subsequently enters a hash (manually), or navigates to a hash of the current URL, re-attempt the injection+decryption flow   fire a configurable callback (default: console.log a message explaining that no password was found) return   fetch the encrypted, remote source bundle (typically named e.g. bundle.js.encrypted) decrypt it if applicable, cache the decryption key (as a hex string) in localStorage if any errors arose, call a configurable callback  by default, check if a cached decryption key was used, and if so, purge it (as evidently the encrypted bundle has changed so that the cached decryption key no longer works)    Key Derivation #  hscrypt uses PBKDF2 (provided by CryptoJS), with SHA512, and defaults to 20k iterations.\n‚ö†Ô∏è 20,000 iterations of SHA512 means you should use passwords with ‚â•60 bits of entropy (see \u0026ldquo;Password strength\u0026rdquo; below). ‚ö†Ô∏è\n‚ö†Ô∏è hscrypt-encrypted bundles are designed to be published on the internet where anyone can download them and point password crackers at them, 24/7, indefinitely into the future. ‚ö†Ô∏è\nYour best defense will always be using a strong(er) password, which also doesn\u0026rsquo;t incur key-derivation time-cost during page load.\nPBKDF2 iterations: 20k x SHA512 #  There is a direct tradeoff between \u0026ldquo;page load time\u0026rdquo; and \u0026ldquo;page security\u0026rdquo; embodied in the iterations param (passed to PBKDF2):\n hscrypt\u0026rsquo;s default configuration (20k x SHA512) loads a page in ‚âà1s on my 2021 Macbook Air. I\u0026rsquo;d like for pages to not be delayed longer than that when loading, so it is imperative that you use a strong enough password so that your page is as secure as you need it to be.  ‚ö†Ô∏è 20k may not be enough iterations! You should compensate with strong passwords (or more iterations) ‚ö†Ô∏è #    OWASP recommendation: 120k iterations of SHA512, or 310k iterations of SHA256\n  1password uses 100k iterations of SHA256, cf. \u0026ldquo;1Password Security Design\u0026rdquo; whitepaper, pg. 19:\n Your account password and the salt are passed to PBKDF2-HMACSHA256 with 100,000 iterations\n As an aside: it\u0026rsquo;s interesting that 1Password is 3x lower than the OWASP recommendation; I interpret them both as targeting a level of security that is beyond what the average hscrypt site requires.\n  Another way to think about it is: for a given level of security, each extra bit of entropy allows for halving the iterations (and therefore key-derivation time)! A very strong password (e.g. a 20-byte Git SHA from a private repository using hscrypt/webpack-plugin) in principle would allow reducing the iterations to 0, and still be as secure as a 145-entropy-bit password (160 - log‚ÇÇ(20,000)).\nPassword strength, $/hashrate #  Here is some envelope-math about how much it may cost to crack passwords of various strengths, given PBKDF2 with 20,000 rounds of SHA512, and an attacker with a hashes-per-dollar ratio equal to that implied by the Bitcoin network:\n   Entropy bits Cost to crack* Hex chars Base64 chars Diceware words     40 $0.01 10 6.7 3.1   45 $1.74 11.25 7.5 3.5   50 $257 12.5 8.3 3.9   55 $38250 13.75 9.2 4.3   60 $5.7MM 15 10 4.6   65 $842MM 16.25 10.8 5   70 $125BN 17.5 11.7 5.4   75 $18,557BN 18.75 12.5 5.8   80 $2,754,191BN 20 13.3 6.2    * Assumptions/Notes:\n Password hashed with PBKDF2, using 20,000 iterations of SHA512 Hashes/$ implied by current BTC hash rate:  Hash rate (‚âà2e20H/s) / block reward (6.25BTC/10mins x $40k/BTC ‚üπ ‚âà$400/s) ‚üπ ‚âà5e17 hashes/$ log‚ÇÇ([‚âà5e17 hashes/$] / [20,000 PBKDF2 iterations]) ‚âà 44.5 bits of entropy ‚âà $1    Conservative assumptions (I hope):\n $/SHA256 = $/SHA512: in reality, SHA512 is supposed to be \u0026ldquo;harder\u0026rdquo; than SHA256. I\u0026rsquo;m assuming it is at least as hard. Assumes attacker $/H equivalent to what BTC miners get with SHA256. Most real-world attackers of hscrypt bundles will presumably pay more per hash.  Again, I am not an expert and no one has vetted any part of this analysis or the hscrypt implementation!\nCredits #   Ben Newman (@benjamn) (lots of JS/TS/WP/ESM/CJS help) Seb Mondet (@smondet) (wrote gitlab.com/smondet/hscrypt, showed/explained it to me) Mykola Bubelich @thesimj (author of thesimj/js-chacha20)  Other inspiration #  robinmoisson/staticrypt: a very similar, apparently popular tool! Demo. I noticed it after I\u0026rsquo;d already done a fair amount of work on hscrypt, and thought I wanted some features or a different design that motivated continuing to write my own version of it anyway, e.g. password in URL hash, webpack integration, decryption-key caching (recently added in staticrypt#124!) and other deployment / configuration things I still haven\u0026rsquo;t gotten around to implementing. It may be that I\u0026rsquo;d have an easier time adding features to staticrypt. I need to do more diligence.\n"}]